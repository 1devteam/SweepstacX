import { readFile, writeFile } from 'node:fs/promises';
import { resolve } from 'node:path';
import { existsSync } from 'node:fs';
import pc from 'picocolors';

/**
 * Export scan report to various formats
 */
export default async function exportReport(opts = {}) {
  const reportPath = resolve(process.cwd(), 'sweepstacx-report.json');
  
  if (!existsSync(reportPath)) {
    console.error(pc.red('✖ Error:'), 'No scan report found. Run "sweepstacx scan" first.');
    return;
  }
  
  const reportData = JSON.parse(await readFile(reportPath, 'utf8'));
  const format = opts.format || 'csv';
  
  if (format === 'csv') {
    await exportToCsv(reportData, opts.output || 'sweepstacx-report.csv');
  } else if (format === 'pdf') {
    await exportToPdf(reportData, opts.output || 'sweepstacx-report.pdf');
  } else if (format === 'json') {
    await exportToJson(reportData, opts.output || 'sweepstacx-export.json');
  } else {
    console.error(pc.red('✖ Error:'), `Unknown format: ${format}`);
    console.log(pc.gray('  Supported formats: csv, pdf, json'));
  }
}

/**
 * Export to CSV format
 */
async function exportToCsv(data, outputPath) {
  const issues = data.issues || [];
  
  // CSV header
  let csv = 'Type,Severity,Message,File,Line,Symbol\n';
  
  // CSV rows
  issues.forEach(issue => {
    const type = (issue.type || '').replace(/,/g, ';');
    const severity = issue.severity || 'info';
    const message = (issue.message || '').replace(/,/g, ';').replace(/\n/g, ' ');
    const file = (issue.file || '').replace(/,/g, ';');
    const line = issue.line || '';
    const symbol = (issue.symbol || '').replace(/,/g, ';');
    
    csv += `"${type}","${severity}","${message}","${file}","${line}","${symbol}"\n`;
  });
  
  await writeFile(outputPath, csv, 'utf8');
  
  console.log(pc.green('✓'), `CSV report exported: ${outputPath}`);
  console.log(pc.gray(`  ${issues.length} issues exported`));
}

/**
 * Export to PDF format (simplified text-based)
 */
async function exportToPdf(data, outputPath) {
  const stats = data.stats || {};
  const issues = data.issues || [];
  const meta = data.meta || {};
  
  // Generate simple text report
  let report = `SWEEPSTACX REPORT\n`;
  report += `${'='.repeat(80)}\n\n`;
  
  report += `Scan Date: ${meta.scanned_at || 'Unknown'}\n`;
  report += `Path: ${meta.path || '.'}\n`;
  report += `Files Scanned: ${stats.totalFiles || 0}\n\n`;
  
  report += `STATISTICS\n`;
  report += `${'-'.repeat(80)}\n`;
  report += `Total Issues: ${issues.length}\n`;
  report += `Unused Imports: ${stats.unusedImports || 0}\n`;
  report += `Dead Files: ${stats.deadFiles || 0}\n`;
  report += `Code Smells: ${stats.codeSmells || 0}\n`;
  report += `Stale Dependencies: ${stats.staleDeps || 0}\n\n`;
  
  report += `ISSUES\n`;
  report += `${'-'.repeat(80)}\n\n`;
  
  // Group by severity
  const bySeverity = { error: [], warning: [], info: [] };
  issues.forEach(issue => {
    const severity = issue.severity || 'info';
    if (!bySeverity[severity]) bySeverity[severity] = [];
    bySeverity[severity].push(issue);
  });
  
  ['error', 'warning', 'info'].forEach(severity => {
    if (bySeverity[severity].length > 0) {
      report += `${severity.toUpperCase()}S (${bySeverity[severity].length})\n`;
      report += `${'-'.repeat(40)}\n`;
      
      bySeverity[severity].forEach((issue, index) => {
        report += `${index + 1}. ${issue.type || 'unknown'}\n`;
        report += `   ${issue.message || 'No message'}\n`;
        report += `   File: ${issue.file || 'Unknown'}${issue.line ? `:${issue.line}` : ''}\n\n`;
      });
      
      report += '\n';
    }
  });
  
  report += `${'='.repeat(80)}\n`;
  report += `Generated by SweepstacX v0.6.0\n`;
  
  // For now, save as text file with .pdf extension
  // In production, you'd use a PDF library like pdfkit
  await writeFile(outputPath.replace('.pdf', '.txt'), report, 'utf8');
  
  console.log(pc.yellow('⚠'), `PDF export saved as text: ${outputPath.replace('.pdf', '.txt')}`);
  console.log(pc.gray('  (Install pdfkit for true PDF generation)'));
  console.log(pc.gray(`  ${issues.length} issues exported`));
}

/**
 * Export to JSON format (formatted)
 */
async function exportToJson(data, outputPath) {
  const formatted = JSON.stringify(data, null, 2);
  await writeFile(outputPath, formatted, 'utf8');
  
  console.log(pc.green('✓'), `JSON report exported: ${outputPath}`);
  console.log(pc.gray(`  ${(data.issues || []).length} issues exported`));
}
